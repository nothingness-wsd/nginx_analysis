继续 main 函数分析

```c
/* TODO */ ngx_max_sockets = -1;
```
初始化最大 socket 数量，-1 表示未设置
后续会根据系统限制设置

---

```c
ngx_time_init();
```
时间系统初始化

- [ngx_time_init](https://blog.csdn.net/weixin_41812346/article/details/156053372?sharetype=blogdetail&sharerId=156053372&sharerefer=PC&sharesource=weixin_41812346&spm=1011.2480.3001.8118)

---

同样的创建 `night/src/core/night_times.c`,
`night/src/core/night_times.h`

在 `night_times.c` 中定义 `night_time_init` 函数

对于预设各种时间格式的字符串的长度这一部分，只保留
```c
night_cached_http_time.len = sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1;
```
`cached_http_time` 用于在 HTTP 响应头中快速输出标准时间，避免每次格式化

其他时间格式暂时搁置，等到之后有明确用途后再考虑

`night_cached_time`全局变量就定义在函数前面

而 `night_time_t` 定义在 `night_times.h`中

```c
typedef struct night_time_s night_time_t;

struct night_time_s
{
    time_t	sec;
    time_t  msec;
    int		gmtoff;
};
```
第一个字段是 秒数，第二个字段是 毫秒数，第三个字段是时区偏移

`night_time_t` 是用 `typedef` 对 `struct night_time_s` 的重定义

这样重定义之后，使用时直接写 `night_time_t` ，相比写 `struct night_time_s` 省去了 `struct`,

如此在形式上更接近像 `int` `char` 这样的基本类型的写法

```
而另一个作用是 typedef 这一行可以分离开写到 night_core.h 的开头去

当有另一个文件 a.h 中需要用到 night_time_t* 类型的指针时，
那么 night_time_t 类型的声明就要写在 a.h 之前，
但如果 night_times.h 中又需要某个 a.h 中的声明时， 那么 a.h 应该写在 night_times.h 之前
这样相互嵌套的关系 可以将 typedef 这一行提出来写到 night_times.h 和 a.h 之前来解决
```

以上就是我对于 为什么要 `typedef` 结构体的思考，

后缀 `_s`,这个 `s` 代表的是 `struct`,

而后缀`_t`,这个 `t` 代表的是 `typedef`。

```
在上述 存在相互嵌套关系时，
如果 a.h 中需要用到的不是 night_time_t* 类型的指针，
而是 night_time_t ，那就需要 night_time_t 的完整定义 也就是 night_time_s{} 部分的定义写在 a.h 之前，
那么前面讲的  typedef 这一行提前的方法也就不行了

这就需要解除头文件相互嵌套的关系，
所以如果一个结构体需要在其他头文件中被使用，那么它就单独占据一个头文件，这个头文件中不再定义另一个结构体，而能够写在这个头文件中的 函数声明 要是操作这个结构体 这样功能的函数，否则就分开写到另一个头文件中，

这样 按逻辑进一步细分，分清楚，分写到不同的头文件中，然后 通过 多个 
#include "header.h"
的写法把多个头文件组合起来，用 逻辑细分 + 组合 使用的方式，避免相互嵌套的方式

同时在创建每一个的 .c 文件， .h 文件时，要明确它的逻辑功能，
它是做什么的，把逻辑分清楚，边界分清楚，
以此判断一个函数或定义，声明 到底应该写在哪一个文件中，让这一切逻辑清晰，都有一个明确的说法，而不能模糊的，似是而非的去决定

一个函数也是如此，要明确它的功能，成为一个明确的逻辑单元，组合到一个更大的整体中去。

这样逻辑明确，可读性高，比一味追求性能更重要，
从我看过的《为什么学生不喜欢上学》《认知天性》等关于认知方法的书籍和观点中可以得知 

人脑的运行内存是有限的，

在我曾看过的另一个关于写作方法的书中也讲到 写的文章要层次分明，而每一层就 3，5 个论点，不要太多，这样对于读者才逻辑清晰，更好理解

对于我们人类而言 人脑的运行内存是有限的，
如果不分出层次，只写一个 main 函数，那么这个 main 函数就太长了，人去阅读它，梳理它的逻辑时，就会感到 运行内存 不够用，

而当它分出层次，把一个 main 函数分作几个逻辑单元的组合时，这个 main 函数的长度就降下来了，我们去梳理它的逻辑时就更容易一些，

而每一个逻辑部分又封装到一个个函数中去实现，这样一个个逻辑单元分层次组合的感觉对于梳理清楚一个庞大系统的逻辑是很有帮助的，
这比起追求性能还要重要，
毕竟一个较大的系统性能差一点也能运行，但是如果逻辑梳理不清楚，那么可就代表着要出现 bug。

事物都有 2 面性，这常体现在一些算法中，
有的算法 时间换空间，有的 空间换时间，都有代价，

在《操作系统之哲学原理》中也多次提到 "差不多"的哲学原理，追求极致是有开销的，要付出代价的，越是追求极致 满分，代价越大，远大于合格的代价

总之，逻辑清晰是我第一追求的目标，而我的性格就是喜欢 慢一点，逻辑更清晰一点，所以我是一个反应迟钝的人，但我要追求逻辑清晰

```

